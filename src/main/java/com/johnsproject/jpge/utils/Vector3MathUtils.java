package com.johnsproject.jpge.utils;

/**
 * The Vector3MathUtils class provides methods for math operations with 3D
 * vectors generated by the {@link VectorUtils} class.
 * 
 * @author JohnÂ´s Project - John Salomon
 * 
 */
public class Vector3MathUtils extends MathUtils {

	private static final int vx = VectorUtils.X, vy = VectorUtils.Y, vz = VectorUtils.Z;

	/**
	 * Adds the values of b to a and returns a.
	 * 
	 * @param a summand vector.
	 * @param b summand vector.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] add(int[] a, int[] b, int[] out) {
		out[vx] = a[vx] + b[vx];
		out[vy] = a[vy] + b[vy];
		out[vz] = a[vz] + b[vz];
		return out;
	}

	/**
	 * Subtracts the values of b from a and returns a.
	 * 
	 * @param a minuend vector.
	 * @param b subtrahend vector.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] subtract(int[] a, int[] b, int[] out) {
		out[vx] = a[vx] - b[vx];
		out[vy] = a[vy] - b[vy];
		out[vz] = a[vz] - b[vz];
		return out;
	}

	/**
	 * Multiplies the values of a and b and returns a.
	 * 
	 * @param a multiplier vector.
	 * @param b multiplicand vector.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] multiply(int[] a, int[] b, int[] out) {
		out[vx] = a[vx] * b[vx];
		out[vy] = a[vy] * b[vy];
		out[vz] = a[vz] * b[vz];
		return out;
	}

	/**
	 * Divides the values of b from a and returns a.
	 * 
	 * @param a dividend vector.
	 * @param b divisor vector.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] divide(int[] a, int[] b, int[] out) {
		out[vx] = a[vx];
		out[vy] = a[vy];
		out[vz] = a[vz];
		if (b[vx] != 0) out[vx] = a[vx] / b[vx];
		if (b[vy] != 0) out[vy] = a[vy] / b[vy];
		if (b[vz] != 0) out[vz] = a[vz] / b[vz];
		return out;
	}

	/**
	 * Adds b to a and returns a.
	 * 
	 * @param a summand vector.
	 * @param b summand value.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] add(int[] a, int b, int[] out) {
		out[vx] = a[vx] + b;
		out[vy] = a[vy] + b;
		out[vz] = a[vz] + b;
		return out;
	}

	/**
	 * Subtracts b from a and returns a.
	 * 
	 * @param a minuend vector.
	 * @param b subtrahend value.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] subtract(int[] a, int b, int[] out) {
		out[vx] = a[vx] - b;
		out[vy] = a[vy] - b;
		out[vz] = a[vz] - b;
		return out;
	}

	/**
	 * Multiplies the values of a with b and returns a.
	 * 
	 * @param a multiplier vector.
	 * @param b multiplicand value.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] multiply(int[] a, int b, int[] out) {
		out[vx] = a[vx] * b;
		out[vy] = a[vy] * b;
		out[vz] = a[vz] * b;
		return out;
	}

	/**
	 * Divides b from a and returns a.
	 * 
	 * @param a dividend vector.
	 * @param b divisor value.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] divide(int[] a, int b, int[] out) {
		out[vx] = a[vx];
		out[vy] = a[vy];
		out[vz] = a[vz];
		if (b != 0) {
			out[vx] = a[vx] / b;
			out[vy] = a[vy] / b;
			out[vz] = a[vz] / b;
		}
		return out;
	}

	/**
	 * Checks witch of the vectors are greater and returns it.
	 * 
	 * @param a first vector.
	 * @param b second vector.
	 * @return the greatest vector.
	 */
	public static int[] max(int[] a, int[] b) {
		int asum = a[vx] + a[vy] + a[vz];
		int bsum = b[vx] + b[vy] + b[vz];
		if (asum > bsum)
			return a;
		else
			return b;
	}

	/**
	 * Checks witch of the vectors are smaller and returns it.
	 * 
	 * @param a first vector.
	 * @param b second vector.
	 * @return the smallest vector.
	 */
	public static int[] min(int[] a, int[] b) {
		int asum = a[vx] + a[vy] + a[vz];
		int bsum = b[vx] + b[vy] + b[vz];
		if (asum > bsum)
			return b;
		else
			return a;
	}

	/**
	 * Moves the given vector by the given angle around the z axis.
	 * 
	 * @param vector vector that contains position to move.
	 * @param angle  angle used to move position.
	 * @param out vector used to store result.
	 * @return moved position.
	 */
	public static int[] movePointByAngleZ(int[] vector, int angle, int[] out) {
		int sin = sin(angle), cos = cos(angle);
		int x = (vector[vx] * cos - vector[vy] * sin) >> SHIFT;
		int y = (vector[vy] * cos + vector[vx] * sin) >> SHIFT;
		out[vx] = x;
		out[vy] = y;
		return out;
	}

	/**
	 * Moves the given vector by the given angle around the y axis.
	 * 
	 * @param vector vector that contains position to move.
	 * @param angle  angle used to move position.
	 * @param out vector used to store result.
	 * @return moved position.
	 */
	public static int[] movePointByAngleY(int[] vector, int angle, int[] out) {
		int sin = sin(angle), cos = cos(angle);
		int x = (vector[vx] * cos - vector[vz] * sin) >> SHIFT;
		int z = (vector[vz] * cos + vector[vx] * sin) >> SHIFT;
		out[vx] = x;
		out[vz] = z;
		return out;
	}

	/**
	 * Moves the given vector by the given angle around the x axis.
	 * 
	 * @param vector vector that contains position to move.
	 * @param angle  angle used to move position.
	 * @param out vector used to store result.
	 * @return moved position.
	 */
	public static int[] movePointByAngleX(int[] vector, int angle, int[] out) {
		int sin = sin(angle), cos = cos(angle);
		int y = (vector[vy] * cos - vector[vz] * sin) >> SHIFT;
		int z = (vector[vz] * cos + vector[vy] * sin) >> SHIFT;
		out[vy] = y;
		out[vz] = z;
		return out;
	}

	/**
	 * Moves the given vector by the given angles around the x, y and z axis.
	 * 
	 * @param vector vector that contains position to move.
	 * @param angles vector that contains angles.
	 * @param out vector used to store result.
	 * @return moved position.
	 */
	public static int[] movePointByAnglesXYZ(int[] vector, int[] angles, int[] out) {
		out = movePointByAngleX(vector, angles[vx], out);
		out = movePointByAngleY(out, angles[vy], out);
		out = movePointByAngleZ(out, angles[vz], out);
		return out;
	}

	/**
	 * Moves the given vector by the given scale.
	 * 
	 * @param vector vector that contains position to move.
	 * @param scale  vector that contains scale.
	 * @param out vector used to store result.
	 * @return moved position.
	 */
	public static int[] movePointByScale(int[] vector, int[] scale, int[] out) {
		return multiply(vector, scale, out);
	}

	/**
	 * Returns a vector containing the distance between vector1 and vector2.
	 * 
	 * @param vector1 fist vector.
	 * @param vector2 second vector.
	 * @param out vector used to store result.
	 * @return vector containing the distance between vector1 and vector2.
	 */
	public static int[] distance(int[] vector1, int[] vector2, int[] out) {
		return subtract(vector1, vector2, out);
	}
	
	/**
	 * Returns the distance between vector1 and vector2.
	 * 
	 * @param vector1 fist vector.
	 * @param vector2 second vector.
	 * @return distance between vector1 and vector2.
	 */
	public static int distance(int[] vector1, int[] vector2) {
		int dx = vector2[vx] - vector1[vx];
		int dy = vector2[vy] - vector1[vy];
		int dz = vector2[vz] - vector1[vz];
		return sqrt(dx * dx + dy * dy + dz * dz);
	}

	/**
	 * Returns the cross product of a and b.
	 * 
	 * @param a fist vector.
	 * @param b second vector.
	 * @param out vector used to store result.
	 * @return cross product of a and b.
	 */
	public static int[] crossProduct(int[] a, int[] b, int[] out) {
		out[vx] = a[vy] * b[vz] - a[vz] * b[vy];
		out[vy] = a[vz] * b[vx] - a[vx] * b[vz];
		out[vz] = a[vx] * b[vy] - a[vy] * b[vx];
		return out;
	}

	/**
	 * Returns the dot product of a and b.
	 * 
	 * @param a fist vector.
	 * @param b second vector.
	 * @return dot product of a and b.
	 */
	public static int dotProduct(int[] a, int[] b) {
		int x = a[vx] * b[vx];
		int y = a[vy] * b[vy];
		int z = a[vz] * b[vz];
		return x + y + z;
	}

	/**
	 * Returns the magnitude of the given vector.
	 * 
	 * @param a vector.
	 * @return magnitude of the given vector.
	 */
	public static int magnitude(int[] a) {
		int x = a[vx] * a[vx];
		int y = a[vy] * a[vy];
		int z = a[vz] * a[vz];
		return MathUtils.sqrt(x + y + z);
	}

	/**
	 * Returns a normalized vector. To get values after modifying the normalized
	 * vector you should do a right shift by the MathUtils.SHIFT. At the normalizing
	 * process the method left shifts the vector values to increase precision. Just
	 * use like this : <br>
	 * 
	 * <code> 
	 * <br> int i = 100;
	 * <br> int[] vector = Vector3Utils.convert(2, 2, 2);
	 * <br> vector = VectorMathUtils.normalize(vector);
	 * <br> vector = VectorMathUtils.multiply(vector, i);
	 * <br> int vx = Vector3Utils.getX(vector) >> MathUtils.SHIFT; // you should shift to get right values
	 * </code>
	 * 
	 * @param a vector.
	 * @param out vector used to store result.
	 * @return normalized vector.
	 */
	public static int[] normalize(int[] a, int[] out) {
		int m = magnitude(a);
		out[vx] = 0;
		out[vy] = 0;
		out[vz] = 0;
		if (m != 0) {
			out[vx] = (a[vx] << SHIFT) / m;
			out[vy] = (a[vy] << SHIFT) / m;
			out[vz] = (a[vz] << SHIFT) / m;
		}
		return out;
	}

	/**
	 * Returns a vector containing only positive values.
	 * 
	 * @param a vector.
	 * @param out vector used to store result.
	 * @return vector containing only positive values.
	 */
	public static int[] abs(int[] a, int[] out) {
		out[vx] = Math.abs(a[vx]);
		out[vy] = Math.abs(a[vy]);
		out[vz] = Math.abs(a[vz]);
		return out;
	}

	/**
	 * Returns a vector containing only negative values.
	 * 
	 * @param a vector.
	 * @param out vector used to store result.
	 * @return vector containing only negative values.
	 */
	public static int[] iabs(int[] a, int[] out) {
		out[vx] = -Math.abs(a[vx]);
		out[vy] = -Math.abs(a[vy]);
		out[vz] = -Math.abs(a[vz]);
		return out;
	}
}
