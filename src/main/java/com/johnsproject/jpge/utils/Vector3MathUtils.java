package com.johnsproject.jpge.utils;

/**
 * The Vector3MathUtils class provides methods for math operations 
 * with 3D vectors generated by the {@link VectorUtils} class.
 * 
 * @author JohnÂ´s Project - John Konrad Ferraz Salomon
 * 
 */
public class Vector3MathUtils extends MathUtils{
	 
	private static final int vx = VectorUtils.X, vy = VectorUtils.Y, vz = VectorUtils.Z;
	
	/**
	 * Adds the values of b to a and returns a.
	 * 
	 * @param a summand vector.
	 * @param b summand vector.
	 * @return a.
	 */
	public static int[] add(int[] a, int[] b) {
		a[vx] = a[vx] + b[vx];
    	a[vy] = a[vy] + b[vy];
    	a[vz] = a[vz] + b[vz];
		return a;
	}
	
	/**
	 * Subtracts the values of b from a and returns a.
	 * 
	 * @param a minuend vector.
	 * @param b subtrahend vector.
	 * @return a.
	 */
	public static int[] subtract(int[] a, int[] b) {
		a[vx] = a[vx] - b[vx];
    	a[vy] = a[vy] - b[vy];
    	a[vz] = a[vz] - b[vz];
		return a;
	}
	
	/**
	 * Multiplies the values of a and b and returns a.
	 * 
	 * @param a multiplier vector.
	 * @param b multiplicand vector.
	 * @return a.
	 */
	public static int[] multiply(int[] a, int[] b) {
		a[vx] = a[vx] * b[vx];
    	a[vy] = a[vy] * b[vy];
    	a[vz] = a[vz] * b[vz];
		return a;
	}
	
	/**
	 * Divides the values of b from a and returns a.
	 * 
	 * @param a dividend vector.
	 * @param b divisor vector.
	 * @return a.
	 */
	public static int[] divide(int[] a, int[] b) {
		if (b[vx] == 0) b[vx] = 1;
		if (b[vy] == 0) b[vy] = 1;
		if (b[vz] == 0) b[vz] = 1;
		a[vx] = a[vx] / b[vx];
    	a[vy] = a[vy] / b[vy];
    	a[vz] = a[vz] / b[vz];
		return a;
	}
	
	/**
	 * Adds b to a and returns a.
	 * 
	 * @param a summand vector.
	 * @param b summand value.
	 * @return a.
	 */
	public static int[] add(int[] a, int b) {
		a[vx] = a[vx] + b;
    	a[vy] = a[vy] + b;
    	a[vz] = a[vz] + b;
		return a;
	}
	
	/**
	 * Subtracts b from a and returns a.
	 * 
	 * @param a minuend vector.
	 * @param b subtrahend value.
	 * @return a.
	 */
	public static int[] subtract(int[] a, int b) {
		a[vx] = a[vx] - b;
    	a[vy] = a[vy] - b;
    	a[vz] = a[vz] - b;
		return a;
	}
	
	/**
	 * Multiplies the values of a with b and returns a.
	 * 
	 * @param a multiplier vector.
	 * @param b multiplicand value.
	 * @return a.
	 */
	public static int[] multiply(int[] a, int b) {
		a[vx] = a[vx] * b;
    	a[vy] = a[vy] * b;
    	a[vz] = a[vz] * b;
		return a;
	}
	
	/**
	 * Divides b from a and returns a.
	 * 
	 * @param a dividend vector.
	 * @param b divisor value.
	 * @return a.
	 */
	public static int[] divide(int[] a, int b) {
		if (b == 0) b = 1;
		a[vx] = a[vx] / b;
    	a[vy] = a[vy] / b;
    	a[vz] = a[vz] / b;
		return a;
	}

	/**
	 * Checks witch of the vectors are greater and returns it.
	 * 
	 * @param a first vector.
	 * @param b second vector.
	 * @return the greatest vector.
	 */
	public static int[] max(int[] a, int[] b) {
		int asum = a[vx] + a[vy] + a[vz];
		int bsum = b[vx] + b[vy] + b[vz];
		if(asum > bsum) return a;
		else return b;
	}
	
	/**
	 * Checks witch of the vectors are smaller and returns it.
	 * 
	 * @param a first vector.
	 * @param b second vector.
	 * @return the smallest vector.
	 */
	public static int[] min(int[] a, int[] b) {
		int asum = a[vx] + a[vy] + a[vz];
		int bsum = b[vx] + b[vy] + b[vz];
		if(asum > bsum) return b;
		else return a;
	}
	
    /**
     * Moves the given vector by the given angle around the z axis.
     * 
     * @param vector vector that contains position to move.
     * @param angle angle used to move position.
     * @return moved position.
     */
    public static int[] movePointByAngleZ(int[] vector, int angle){
    	int sin = sin(angle), cos = cos(angle);
    	int x = ((vector[vx] * cos - vector[vy] * sin) >> SHIFT);
    	int y = ((vector[vy] * cos + vector[vx] * sin) >> SHIFT);
    	vector[vx] = x;
    	vector[vy] = y;
    	return vector;
    }
    
    /**
     * Moves the given vector by the given angle around the y axis.
     * 
     * @param vector vector that contains position to move.
     * @param angle angle used to move position.
     * @return moved position.
     */
    public static int[] movePointByAngleY(int[] vector, int angle){
    	int sin = sin(angle), cos = cos(angle);
    	int x = ((vector[vx] * cos - vector[vz] * sin) >> SHIFT);
    	int z = ((vector[vz] * cos + vector[vx] * sin) >> SHIFT);
    	vector[vx] = x;
    	vector[vz] = z;
    	return vector;
    }
    
    /**
     * Moves the given vector by the given angle around the x axis.
     * 
     * @param vector vector that contains position to move.
     * @param angle angle used to move position.
     * @return moved position.
     */
    public static int[] movePointByAngleX(int[] vector, int angle){
    	int sin = sin(angle), cos = cos(angle);
    	int y = ((vector[vy] * cos - vector[vz] * sin)) >> SHIFT;
    	int z = ((vector[vz] * cos + vector[vy] * sin)) >> SHIFT;
    	vector[vy] = y;
    	vector[vz] = z;
    	return vector;
    }
    
    /**
     * Moves the given vector by the given angles around the x, y and z axis.
     * 
     * @param vector vector that contains position to move.
     * @param angles vector that contains angles.
     * @return moved position.
     */
    public static int[] movePointByAnglesXYZ(int[] vector, int[] angles){
    	vector = movePointByAngleX(vector, angles[vx]);
    	vector = movePointByAngleY(vector, angles[vy]);
    	vector = movePointByAngleZ(vector, angles[vz]);
    	return vector;
    }
    
    /**
     * Moves the given vector by the given scale.
     * 
     * @param vector vector that contains position to move.
     * @param scale vector that contains scale.
     * @return moved position.
     */
    public static int[] movePointByScale(int[] vector, int[] scale){
    	return multiply(vector, scale);
    }
    
    /**
     * Returns a vector containing the distance between vector1 and vector2.
     * 
     * @param vector1 fist vector.
     * @param vector2 second vector.
     * @return vector containing the distance between vector1 and vector2.
     */
    public static int[] getDistance(int[] vector1, int[] vector2) {
    	return subtract(vector1, vector2);
    }
    
    /**
     * Returns the cross product of a and b.
     * 
     * @param a fist vector.
     * @param b second vector.
     * @return cross product of a and b.
     */
    public static int[] crossProduct(int[] a, int[] b) {
    	int x = a[vy]*b[vz] - a[vz]*b[vy];
    	int y = a[vz]*b[vx] - a[vx]*b[vz];
    	int z = a[vx]*b[vy] - a[vy]*b[vx];
		return new int[] {x, y, z};
    }
    
    /**
     * Returns the dot product of a and b.
     * 
     * @param a fist vector.
     * @param b second vector.
     * @return dot product of a and b.
     */
    public static int dotProduct(int[] a, int[] b) {
		int x = a[vx]*b[vx];
    	int y = a[vy]*b[vy];
    	int z = a[vz]*b[vz];
		return x + y + z;
    }
    
    /**
     * Returns the magnitude of the given vector.
     * 
     * @param a vector.
     * @return magnitude of the given vector.
     */
    public static int magnitude(int[] a) {
    	int x = a[vx]*a[vx];
    	int y = a[vy]*a[vy];
    	int z = a[vz]*a[vz];
    	return MathUtils.sqrt(x + y + z);
    }
    
    /**
     * Returns a normalized vector.
     * To get values after modifying the normalized vector you should do a right shift by the MathUtils.SHIFT.
     * At the normalizing process the method left shifts the vector values to increase precision. 
     * Just use like this : <br>
	 * 
	 * <code> 
	 * <br> int i = 100;
	 * <br> int[] vector = Vector3Utils.convert(2, 2, 2);
	 * <br> vector = VectorMathUtils.normalize(vector);
	 * <br> vector = VectorMathUtils.multiply(vector, i);
	 * <br> int vx = Vector3Utils.getX(vector) >> MathUtils.SHIFT; // you should shift to get right values
	 * </code>
	 * 
     * @param a vector.
     * @return normalized vector.
     */
    public static int[] normalize(int[] a) {
    	int m = magnitude(a);
    	if (m == 0) m = 1;
    	a[vx] = (a[vx] << SHIFT) / m;
    	a[vy] = (a[vy] << SHIFT) / m;
    	a[vz] = (a[vz] << SHIFT) / m;
    	return a;
    }
    
    /**
     * Returns a vector containing only positive values.
     * @param a vector.
     * @return vector containing only positive values.
     */
    public static int[] abs(int[] a) {
    	a[vx] = Math.abs(a[vx]);
    	a[vy] = Math.abs(a[vy]);
    	a[vz] = Math.abs(a[vz]);
    	return a;
    }
    
    /**
     * Returns a vector containing only negative values.
     * @param a vector.
     * @return vector containing only negative values.
     */
    public static int[] iabs(int[] a) {
    	a[vx] = -Math.abs(a[vx]);
    	a[vy] = -Math.abs(a[vy]);
    	a[vz] = -Math.abs(a[vz]);
    	return a;
    }
}
