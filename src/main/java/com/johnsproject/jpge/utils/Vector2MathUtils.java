package com.johnsproject.jpge.utils;

/**
 * The Vector2MathUtils class provides methods for math operations with 2D
 * vectors generated by the {@link VectorUtils} class.
 * 
 * @author JohnÂ´s Project - John Salomon
 * 
 */
public class Vector2MathUtils extends MathUtils {

	private static final int vx = VectorUtils.X, vy = VectorUtils.Y;

	/**
	 * Adds the values of b to a and returns a.
	 * 
	 * @param a summand vector.
	 * @param b summand vector.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] add(int[] a, int[] b,  int[] out) {
		out[vx] = a[vx] + b[vx];
		out[vy] = a[vy] + b[vy];
		return out;
	}

	/**
	 * Subtracts the values of b from a and returns a.
	 * 
	 * @param a minuend vector.
	 * @param b subtrahend vector.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] subtract(int[] a, int[] b,  int[] out) {
		out[vx] = a[vx] - b[vx];
		out[vy] = a[vy] - b[vy];
		return out;
	}

	/**
	 * Multiplies the values of a and b and returns a.
	 * 
	 * @param a multiplier vector.
	 * @param b multiplicand vector.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] multiply(int[] a, int[] b,  int[] out) {
		out[vx] = a[vx] * b[vx];
		out[vy] = a[vy] * b[vy];
		return out;
	}

	/**
	 * Divides the values of b from a and returns a.
	 * 
	 * @param a dividend vector.
	 * @param b divisor vector.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] divide(int[] a, int[] b,  int[] out) {
		out[vx] = a[vx];
		out[vy] = a[vy];
		if (b[vx] != 0) out[vx] = a[vx] / b[vx];
		if (b[vy] != 0) out[vy] = a[vy] / b[vy];
		return out;
	}

	/**
	 * Adds b to a and returns a.
	 * 
	 * @param a summand vector.
	 * @param b summand value.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] add(int[] a, int b, int[] out) {
		out[vx] = a[vx] + b;
		out[vy] = a[vy] + b;
		return out;
	}

	/**
	 * Subtracts b from a and returns a.
	 * 
	 * @param a minuend vector.
	 * @param b subtrahend value.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] subtract(int[] a, int b, int[] out) {
		out[vx] = a[vx] - b;
		out[vy] = a[vy] - b;
		return out;
	}

	/**
	 * Multiplies the values of a with b and returns a.
	 * 
	 * @param a multiplier vector.
	 * @param b multiplicand value.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] multiply(int[] a, int b, int[] out) {
		out[vx] = a[vx] * b;
		out[vy] = a[vy] * b;
		return out;
	}

	/**
	 * Divides b from a and returns a.
	 * 
	 * @param a dividend vector.
	 * @param b divisor value.
	 * @param out vector used to store result.
	 * @return a.
	 */
	public static int[] divide(int[] a, int b, int[] out) {
		out[vx] = a[vx];
		out[vy] = a[vy];
		if (b != 0) {
			out[vx] = a[vx] / b;
			out[vy] = a[vy] / b;
		}
		return out;
	}

	/**
	 * Checks witch of the vectors are greater and returns it.
	 * 
	 * @param a first vector.
	 * @param b second vector.
	 * @return the greatest vector.
	 */
	public static int[] max(int[] a, int[] b) {
		int asum = a[vx] + a[vy];
		int bsum = b[vx] + b[vy];
		if (asum > bsum)
			return a;
		else
			return b;
	}

	/**
	 * Checks witch of the vectors are smaller and returns it.
	 * 
	 * @param a first vector.
	 * @param b second vector.
	 * @return the smallest vector.
	 */
	public static int[] min(int[] a, int[] b) {
		int asum = a[vx] + a[vy];
		int bsum = b[vx] + b[vy];
		if (asum > bsum)
			return b;
		else
			return a;
	}

	/**
	 * Moves the given vector by the given angle around the z axis.
	 * 
	 * @param vector vector that contains position to move.
	 * @param angle  angle used to move position.
	 * @param out vector used to store result.
	 * @return moved position.
	 */
	public static int[] movePointByAngleZ(int[] vector, int angle, int[] out) {
		int sin = sin(angle), cos = cos(angle);
		int x = ((vector[vx] * cos - vector[vy] * sin) >> SHIFT);
		int y = ((vector[vy] * cos + vector[vx] * sin) >> SHIFT);
		out[vx] = x;
		out[vy] = y;
		return out;
	}

	/**
	 * Moves the given vector by the given scale.
	 * 
	 * @param vector vector that contains position to move.
	 * @param scale  vector that contains scale.
	 * @param out vector used to store result.
	 * @return moved position.
	 */
	public static int[] movePointByScale(int[] vector, int[] scale, int[] out) {
		return multiply(vector, scale, out);
	}

	/**
	 * Returns a vector containing the distance between vector1 and vector2.
	 * 
	 * @param vector1 fist vector.
	 * @param vector2 second vector.
	 * @param out vector used to store result.
	 * @return vector containing the distance between vector1 and vector2.
	 */
	public static int[] distance(int[] vector1, int[] vector2, int[] out) {
		return subtract(vector1, vector2, out);
	}
	
	/**
	 * Returns the distance between vector1 and vector2.
	 * 
	 * @param vector1 fist vector.
	 * @param vector2 second vector.
	 * @return distance between vector1 and vector2.
	 */
	public static int distance(int[] vector1, int[] vector2) {
		int dx = vector2[vx] - vector1[vx];
		int dy = vector2[vy] - vector1[vy];
		return sqrt(dx * dx + dy * dy);
	}

	/**
	 * Returns the dot product of a and b.
	 * 
	 * @param a fist vector.
	 * @param b second vector.
	 * @return dot product of a and b.
	 */
	public static int dotProduct(int[] a, int[] b) {
		int x = a[vx] * b[vx];
		int y = a[vy] * b[vy];
		return x + y;
	}

	/**
	 * Returns the magnitude of the given vector.
	 * 
	 * @param a vector.
	 * @return magnitude of the given vector.
	 */
	public static int magnitude(int[] a) {
		int x = a[vx] * a[vx];
		int y = a[vy] * a[vy];
		return MathUtils.sqrt(x + y);
	}

	/**
	 * Returns a normalized vector. To get values after modifying the normalized
	 * vector you should do a right shift by the MathUtils.SHIFT. At the normalizing
	 * process the method left shifts the vector values to increase precision. Just
	 * use like this : <br>
	 * 
	 * <code> 
	 * <br> int i = 100;
	 * <br> int[] vector = Vector3Utils.convert(2, 2, 2);
	 * <br> vector = VectorMathUtils.normalize(vector);
	 * <br> vector = VectorMathUtils.multiply(vector, i);
	 * <br> int vx = Vector3Utils.getX(vector) >> MathUtils.SHIFT; // you should shift to get right values
	 * </code>
	 * 
	 * @param a vector.
	 * @param out vector used to store result.
	 * @return normalized vector.
	 */
	public static int[] normalize(int[] a, int[] out) {
		int m = magnitude(a);
		out[vx] = 0;
		out[vy] = 0;
		if (m != 0) {
			out[vx] = (a[vx] << SHIFT) / m;
			out[vy] = (a[vy] << SHIFT) / m;
		}
		return out;
	}

	/**
	 * Returns a vector containing only positive values.
	 * 
	 * @param a vector.
	 * @param out vector used to store result.
	 * @return vector containing only positive values.
	 */
	public static int[] abs(int[] a, int[] out) {
		out[vx] = Math.abs(a[vx]);
		out[vy] = Math.abs(a[vy]);
		return out;
	}

	/**
	 * Returns a vector containing only negative values.
	 * 
	 * @param a vector.
	 * @param out vector used to store result.
	 * @return vector containing only negative values.
	 */
	public static int[] iabs(int[] a, int[] out) {
		out[vx] = -Math.abs(a[vx]);
		out[vy] = -Math.abs(a[vy]);
		return out;
	}
}
